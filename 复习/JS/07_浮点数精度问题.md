为什么 0.1 + 0.2 === 0.3   false?

### 存储规则

待解决：为什么JS只有Number类型？不像其它语言一样有int,float之分

+ JS中只存在`Number`类型，它的实现遵循 IEEE 754 标准，使用64位固定长度来表示，也就是标准的 double 双精度浮点数。
+ 这样的存储结构优点是可以归一化处理整数和小数，节省储存空间。

+ 其中64位划分为三个部分
  + 符号位`S`:1 位
  + 指数位 `E`:11 位
  + 位数为`M`:52 位



### 如何储存

#### 转化为二进制

+ 已知：10转化为二进制为：`10 = 1*2^3+0*2^2+1*2^1+0*2^0`

+ 那么 0.75转化为二进制为

  ```
  设 0.75 = a*2^-1 + b*2^-2 + c*2^-3......
   两边同时乘以二得：
    1+0.5 = a*2^0 + b*2^-1 + c*2^-2.....
   解得 a=1;
   0.5 = b*2^-1 + c*2^-2.....
   乘以二得：
   1 = b*2^0 + c*2^-1
   解得 b=1
  所以0.75的二进制表示为：
   0.11
  ```

+ 可不是所有的浮点数都这么好算，例如 0.1

  ```
  0.1 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ...
  0 + 0.2 = a * 2^0 + b * 2^-1 + c * 2^-2 + ...   (a = 0)
  0 + 0.4 = b * 2^0 + c * 2^-1 + d * 2^-2 + ...   (b = 0)
  0 + 0.8 = c * 2^0 + d * 2^-1 + e * 2^-2 + ...   (c = 0)
  1 + 0.6 = d * 2^0 + e * 2^-1 + f * 2^-2 + ...   (d = 1)
  1 + 0.2 = e * 2^0 + f * 2^-1 + g * 2^-2 + ...   (e = 1)
  0 + 0.4 = f * 2^0 + g * 2^-1 + h * 2^-2 + ...   (f = 0)
  0 + 0.8 = g * 2^0 + h * 2^-1 + i * 2^-2 + ...   (g = 0)
  1 + 0.6 = h * 2^0 + i * 2^-1 + j * 2^-2 + ...   (h = 1)
  ....
  所以 0.1 = 0.00011001....
  ```

#### 二进制科学记数

+ 根据规则，转化为`V = (-1)^S * (1 + Fraction) * 2^E`模式，s=0,，v为正数；s=1，v为负数
+ 例如上面的 10 转化为科学计数为：`(-1)^0 * (1+0.01) * 2^3`
+ 0.75转化为科学记数为: `(-1)^0 * (1+0.1) * 2^-1`
+ 0.1 : `(-1)^0 * 1 * 1.1001100110011…… * 2^-4`



#### 储存

+ 可以看出 E 可以为正数 或者 负数， 但分配给 E 的内存为11 位， 算一位符号位的话，范围为`-1023 ~ 1023`，不算符号位只需要所有数加上`1023`，例如 `-1023`用0表示 

+ M (`Fraction`)部分位52位，则超出部分将进行舍入（0舍1入），就会发生精度丢失



### 运算

+ 浮点数的运算有以下五个步骤完成：对阶，尾数运算，规格化，舍入处理，溢出判断
+ 对阶：例如 `x*2^-3 + y^2*-4`，将会把阶数调为一致（小阶对大阶）
+ 尾数运算：二进制加减法得出结果
+ 规格化，舍入处理：将求得的结果再次科学计数化，超出部分舍弃（0舍1入）
+ 溢出判断



### 结果

浮点数储存时的精度丢失以及运算时的精度丢失导致最终结果的不准确性。



### 解决办法

[解决toFixed问题 以及 计算精度问题](https://juejin.cn/post/6844903572979597319#heading-8)

