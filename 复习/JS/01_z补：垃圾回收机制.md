### 参考资料

+ [你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214#heading-12)



### 垃圾回收策略

#### 标记清除法（大多数的选择）

##### 步骤

+ 垃圾收集器在运行时给内存中的所有变量加上一个标记，先假设所有对象都是垃圾，全部标记为0
+ 然后从各个根对象（windows对象，文档DOM树等）开始遍历，把不是垃圾的节点改为1（可达的节点）
+ 清理所有标记为0的垃圾，并销毁他们所占用的内存空间
+ 把内存中的所有对象标记为0，等待下一次GC

##### 优点

+ 简单

##### 缺点

+ 内存碎片化
+ 分配速度慢（对于内存碎片的分配策略）

**标记整理（Mark-Compact）算法** 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存



#### 引用计数法

##### 步骤

+ 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1

+ 如果同一个值又被赋给另一个变量，那么引用数加 1

+ 如果该变量的值被其他的值覆盖了，则引用次数减 1

+ 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存

##### 优点

+ 当计数变为0时立刻被回收，而标记清理法是每隔一段时间执行一次

##### 缺点

+ 计数器需要额外的开销
+ 属性间的循环引用，没法清理内存



### V8的优化

#### 分代式垃圾回收

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-watermark.awebp)

+ 新生代：存活事件较短的对象（新产生的对象）

+ 老生代：存活时间较长或常驻内存的对象

##### 新生代垃圾回收

+ `Cheney算法` 中将新生代堆内存一分为二，一个个是处于使用状态的空间我们暂且称之为 使用区，一个是处于闲置状态的空间我们称之为空闲区

+ 对于新加入的对象，将他放入使用区，当使用区快被写满时，就执行一次垃圾清理操作
+ 对使用区里的活动对象做标记，然后将标记后的对象复制进空闲区中并进行排序；随后清空使用区，将使用区变为空闲区，空闲区变为使用区。
+ 当一个对象经过多次复制后仍然存活，则将它放进老生代里。
+ 另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 `Scavenge` 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配。

##### 老生代垃圾回收

+ 对于老生代里的对象，垃圾回收步骤同标记清除法相同。

##### 优点

+ 提高效率



#### 并行回收

+ 全停顿：我们都知道 `JavaScript` 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 `JavaScript` 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做 `全停顿`

+ 为了减短全停顿的时间，采用并行回收，即添加多个辅助线程一起回收
+ 新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，此即并行回收

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0eef6c0d3bd49659a564fe698d17f43~tplv-k3u1fbpfcp-watermark.awebp)



#### 增量标记与懒性清理

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e16d93c2c8414d3ab7eac55c852c678a~tplv-k3u1fbpfcp-watermark.awebp)



##### 三色标记法

对于增量标记，如果采用传统的标记清理法，很难判断哪些已经检查标记过，因此采用三色标记法

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b012d88c1f064eaebd0df60a9aadb85e~tplv-k3u1fbpfcp-watermark.awebp)

+ 黑色代表可达点，白色代表不可达或还未到达的点，灰色代表上一次检查执行到的点。

+ 从一组根对象开始，先将这组根对象标记为灰色并推入到标记工作表中，当回收器从标记工作表中弹出对象并访问它的引用对象时，将其自身由灰色转变成黑色，并将自身的下一个引用对象转为灰色。
+ 就这样一直往下走，直到没有可标记灰色的对象时，也就是无可达（无引用到）的对象了，那么剩下的所有白色对象都是无法到达的，即等待回收（如上图中的 `C、E` 将要等待回收）
+ 可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成，如没有灰色节点，直接进入清理阶段，如还有灰色标记，恢复时直接从灰色的节点开始继续执行就可以。



##### 写屏障

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bada1914eff449b48b5a14e53c107ff3~tplv-k3u1fbpfcp-watermark.awebp)

+ 在上一次增量中，B引用了C，当后来B引用D时，此时D是白色而C是黑色，由于没有灰色，将导致D被清理，这肯定是不对的。（C是黑色问题不大，因为他会在下一次垃圾清理中被清除）
+ 因此当出现黑色部分引用白色时，将强制把白色变为灰色，从而保证下一次增量 `GC` 标记阶段可以正确标记，这个机制也被称作 **强三色不变**



##### 惰性清理

+ 增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 V8 采用的是惰性清理(Lazy Sweeping)

+ 增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是**没必要立即清理**内存的，可以将清理过程稍微延迟一下，让 `JavaScript` 脚本代码先执行，也**无需一次性清理**完所有非活动对象内存，可以按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记

  

#### 优缺点

+ 使得主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅。
+ 首先是并没有减少主线程的总暂停的时间，甚至会略微增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量（吞吐量是啥总不用说了吧）

