### 参考文献

+ [说说作用域和闭包](https://juejin.cn/post/6844904165672484871#comment)

### 定义

+ 自由变量：指在函数中使用，但既不是函数参数，也不是函数局部变量的变量
+ 理论角度：指那些能够访问自由变量的函数（但按照这个定义，所有的函数都是闭包...)
+ 实践角度：
  + 即使创建它的上下文已经销毁，它仍然存在
  + 引用了自由变量
+ 闭包就是一个作用域里的变量可以访问到另一个作用域的变量。
+ 本质就是上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放。
+ 一般情况下，并不是保持整个上级作用域不被释放，仅仅保持对可用对象的连接；但存在eval时，因为不确定是否能安全的清除，所以将会保持整个上级作用域。

### 例子

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope();
foo();
```

+ 创建全局上下文，并初始化
+ 把全局上下文压入执行栈
+ 创建`checkscope`的上下文，初始化（包括f函数的作用域）
+ 把`checkscope`压入执行栈
+ 执行官完毕,`checkscope`出栈
+ 创建`foo`函数执行上下文，初始化，（包括变量环境和词法环境中的外环境引用）
+ `foo`执行完毕，出栈

`f`函数之所以还能访问到已经出栈的`checkscope`函数里的变量，是因为他的作用域链里仍然包含了`checkscope`里的变量（**存疑**）

